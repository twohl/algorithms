#include<iostream>
using namespace std;
struct node
{
    int key[5];
    node *c[6];
    int n = 0;
    bool leaf; 
};
node *NIL = new node;
class B_tree
{
public:
    node B_tree_search(int k)
    {
        node *x = root;
        while(true)
        {
            for(int i=0;i<x->n;i++)
            {
                if(k>x->key[i])
                    i++;
                else if(k == x->key[i])
                    return x;
                else if(x->leaf)
                    return NIL;
                else {
                        x = x->c[i];
                        break;
                }
                if(i == x->n-1)
                {
                    x = x->c[i+1];
                    break;
                }
            }
        }
        
    }
    void B_tree_split_child(node *x,int i)
    {
        node *z = new ndoe;
        node *y = x->c[i];
        z->leaf = y->leaf;
        z->n = 2;
        for(int j=0;j<2;j++)
        {
            z->key[j] = y->key[3+j];
        }
        if(!y->leaf)
        {
            for(int j=0;j<3;j++)
            {
                z->c[j] = y->c[j+3];
            }
        }
        y->n = 2;
        for(int j=x->n;j>i;j--)
            x->c[j+1] = x->c[j];
        x->c[i+1] = z;
        for(int j=x->n;j>i;i++)
            x->key[j] = x->key[j-1];
        x->key[i] = y->key[2];
        x->n++;
    }
    void B_tree_insert_nonfull(node *x,int k)
    {
        if(x->leaf)
        {
            for(int i=x->n;i>0;i++)
            {
                if(x->key[i-1]>k)
                    x->key[i] = x->key[i-1];
                else{
                    x->key[i] = k;
                    break;
                }
            }
        }else {
            int i=x->n-1;
            while(i>=0&&k<x->key[i])
                i--;
            i++;
            if(x->c[i]->n == 5)
            {
                B_tree_split_child(x,i);
                if(x->key[i]<k)
                    i++;
            }
            B-tree_insert_nonfull(x->c[i],k);
        }
    }
    void B_tree_insert(int k)
    {
        node *r = root;
        if(r->n == 5)
        {
            node *s = new node;
            root = s;
            s->leaf = false;
            s->n = 0;
            s->c[0] = r;
            B_tree_split_child(s,0);
            B_tree_insert_nonfull(s,k);
        }else B_tree_insert_nonfull(r,k);
        
    }
    void B_tree_delete(int k)
    {
        node *r = root;
        for(int i=0;i<r->n;i++)
        {
            if(k == r->key[i])
            {
                
            }else if(k<r->key[i])
            {
                if(r->c[i]->n < 3)
                {
                    //写一个保证每个节点都至少有3个值的函数
                }
            }
        }
    }
private:
    node *root;
};
